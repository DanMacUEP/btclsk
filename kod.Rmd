---
title: "Agregacja danych + wykresy"
output: html_notebook
---


```{r}
library(tseries)
```


```{r}
library(openxlsx)
library(stats)

```

```{r}
BTC <- read.xlsx("data/BTC.xlsx", sheet = 1)
```

```{r}
LSK <-read.xlsx("data/LSK.xlsx", sheet = 1)
```

```{r}
LSK$Close = as.numeric(LSK$Close)
```

```{r}
LSK$Miesiac = as.factor(LSK$Miesiac)
```

```{r}
BTC$Close = as.numeric(BTC$Close)
```

```{r}
BTC$Miesiac = as.factor(BTC$Miesiac)
```



```{r}
class(LSK)
class(BTC)
```


LSK.Close <- LSK[, "Close**"]
LSK.Close


```{r}
head(LSK)
```






```{r}
head(BTC)
```


```{r}
szereg <- LSK
```

```{r}
szereg2 <- BTC
```


```{r}
tail(BTC)
```


```{r}
library(sqldf)
library(dplyr)
```








```{r}
LSK.year <- LSK %>% 
    select(Rok, Close) %>%
    na.omit() %>%
    group_by(Rok) %>% summarise(roczneLSK = mean(Close))

 
head(LSK.year)
```


```{r}
BTC.year <- BTC %>% 
    select(Rok, Close) %>%
    na.omit() %>%
    group_by(Rok) %>% summarise(roczneBTC = mean(Close))

 
head(BTC.year)
```




```{r}
LSK.mie <- LSK %>%   filter(Rok %in% c(2016, 2017, 2018)) %>% 
    select(Rok, Miesiac, Close) %>% na.omit() %>%
    mutate(Miesiac = factor(month.name[Miesiac], levels=month.name[1:12]),
           Rok = factor(Rok),
           Close.CEL = (Close)) %>%    
    group_by(Rok, Miesiac) %>% summarise(Close.mean = round(mean(Close.CEL),2))

 
head(LSK.mie)
```



```{r}
BTC.mie <- BTC %>%   filter(Rok %in% c(2013, 2014, 2015, 2016, 2017, 2018)) %>% 
    select(Rok, Miesiac, Close) %>% na.omit() %>%
    mutate(Miesiac = factor(month.name[Miesiac], levels=month.name[1:12]),
           Rok = factor(Rok),
           Close.CEL = (Close)) %>%    
    group_by(Rok, Miesiac) %>% summarise(Close.mean = round(mean(Close.CEL),2))

 
head(BTC.mie)
```




```{r}
library(ggplot2)

```


```{r}

p.title <- "LSK-rocznie (agregacja po średniej)"
qplot(Rok, roczneLSK, data = LSK.year, 
  main = p.title,
  xlab = "Rok", ylab = "Close") + geom_line(size=0.5)
```





```{r}
p.title <- paste0("LSK-miesięcznie (agregacja po średniej)")
ggplot(LSK.mie, aes(x=Miesiac, y=Close.mean, group=Rok)) + 
    geom_line(aes(colour = Rok), size = 0.8) + 
    xlab("Miesiąc") + ylab("Close") + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = p.title)
```






```{r}
p.title <- "BTC-rocznie (agregacja po średniej)"
qplot(Rok, roczneBTC, data = BTC.year, 
  main = p.title,
  xlab = "Rok", ylab = "Close") + geom_line(size=0.5)
```


obrazeknumer1

```{r}
BTC.mie <- BTC %>%   filter(Rok %in% c(2013, 2014, 2015, 2016, 2017, 2018)) %>% 
    select(Rok, Miesiac, Close) %>% na.omit() %>%
    mutate(Miesiac = factor(month.name[Miesiac], levels=month.name[1:12]),
           Rok = factor(Rok),
           Close.CEL = (Close)) %>%    
    group_by(Rok, Miesiac) %>% summarise(Close.mean = round(mean(Close.CEL),2))

 
head(BTC.mie)
```




```{r}
plot(BTC.mie$Close.mean, type="l", lwd=2, xlab="miesiąc", ylab="kurs zamknięcia")
```


```{r}
zbiordanych <- BTC
```


```{r}
BTC.mie
```


```{r}
plot(BTC.mie$Close.mean, type="l", lwd=2, xlab=NA, ylab="średni kurs zamknięcia (USD)", axes = F)
axis(side=1, at=c(1,7,13,19,25,31,37,43,49,55,61,67), labels=c("Maj 2013","Lis 2013", "Maj 2014","Lis 2014","Maj 2015","Lis 2015","Maj 2016","Lis 2016","Maj 2016","Lis 2017","Maj 2017","Lis 2018"), las=2)
axis(side=2, at=c(0,5000,10000,15000), labels=c("0", "5000","10000","15000"))
## chodzi o to, zeby pokazac np sty 2011 sty 2012 sty 2013 sty 2014 itd
box()
```

```{r}
plot(LSK.mie$Close.mean, type="l", lwd=2, xlab=NA, ylab="średni kurs zamknięcia (USD)", axes = F)
axis(side=1, at=c(1,7,13,19,25,31), labels=c("Kwi 2016","Paź 2016", "Kwi 2017","Paź 2017","Kwi 2018","Paź 2017"), las=2)
axis(side=2, at=c(0,5,10,15,20,25), labels=c("0", "5","10","15","20","25"))
box()
```

```{r}
LSK.mie
```


```{r}
ggplot(BTC.mie, aes(x=Miesiac, y=Close.mean)) + 
  geom_line()
```




```{r}
plot(BTC.mie$Miesiac , BTC.mie$Close.mean, type="l", col="green", lwd=5, xlab="miesiac", ylab="cena", main="ciekawa rzecz")
```


```{r}
p.title <- paste0("BTC-miesięcznie (agregacja po średniej)")
ggplot(BTC.mie, aes(x=Miesiac, y=Close.mean, group=Rok)) + 
    geom_line(aes(colour = Rok), size = 0.8) + 
    xlab("Miesiąc") + ylab("Close") + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = p.title)
```


```{r}
p.title <- paste0("BTC-miesięcznie (agregacja po średniej)")
ggplot(BTC.mie, aes(x=Miesiac, y=Close.mean, group=Rok)) + 
    geom_line(aes(colour = Rok), size = 0.8) + 
    xlab("Miesiąc") + ylab("Close") + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = p.title)
```


```{r}
p.title <- "Wykres LSK w dniach (dla kazdej obserwacji)"
qplot(950:1, LSK$Close, data = LSK, 
  main = p.title,
  xlab = "Obserwacja", ylab = "Close") + geom_line(size=0.5)
```


```{r}
dim(BTC)
```


```{r}
p.title <- "Wykres BTC w dniach(dla kazdej obserwacji)"
qplot(2024:1, BTC$Close, data = BTC, 
  main = p.title,
  xlab = "Obserwacja", ylab = "Close") + geom_line(size=0.5)
```




```{r}
LSK_M<-c(LSK.mie$Close.mean)
srednie_wartosci_miesieczne_LSK <- ts(LSK_M, start=c(2016,4), frequency=12)
srednie_wartosci_miesieczne_LSK
```

```{r}
LSK_f_M<-c(LSK_f.mie$Close.mean)
srednie_wartosci_miesieczne_LSK_f <- ts(LSK_f_M, start=c(2016,4), frequency=12)
srednie_wartosci_miesieczne_LSK_f
```



```{r}
srednie_wartosci_kwartalne_LSK <-  aggregate(srednie_wartosci_miesieczne_LSK, nfrequency=4, FUN = mean)
srednie_wartosci_kwartalne_LSK
```

```{r}
plot(srednie_wartosci_kwartalne_LSK, main ="Wykres LSK agregacja kwartalna (po średniej) ")
```




```{r}
BTC_M<-c(BTC.mie$Close.mean)
srednie_wartosci_miesieczne_BTC <- ts(BTC_M, start=c(2013,4), frequency=12)
srednie_wartosci_miesieczne_BTC

```




```{r}
srednie_wartosci_kwartalne_BTC <-  aggregate(srednie_wartosci_miesieczne_BTC, nfrequency=4, FUN = mean)
srednie_wartosci_kwartalne_BTC
```


    
    




```{r}
plot(srednie_wartosci_kwartalne_BTC, main ="Wykres BTC agregacja kwartalna (po średniej) ")
```

    
    
    
    
    
    

```{r}

dji.Close <- LSK[, "Close"]
head(dji.Close)


```


```{r}
m3 <- filter(dji.Close, sides = 2, filter = rep(1 / 3, 3))

m11 <- filter(dji.Close, sides = 2, filter = rep(1 /11, 11))
              
m21 <- filter(dji.Close, sides = 2, filter = rep(1 / 21, 21))
``` 





```{r}
head(m3,n=12)

```

```{r}
tail(m3,n=12)
```


```{r}
head(m11,n=12)
```

```{r}
tail(m11,n=12)

```


```{r}
head(m21,n=12)
```


```{r}
tail(m21,n=12)

```





```{r}
sum(is.na(m11))
```


```{r}
m11.noNA <- na.omit(m11)
sum(is.na(m11.noNA))
```


```{r}
plot(m3,
     main = paste("Metoda ruch średniej"),col = "blue", lty =2)
lines(m11, col = "red", lty = 2)
lines(m21, col = "green", lty = 2)
lines(dji.Close, col = "black", lty = 1)
grid()
legend("topright",
       legend = c("naszeLSK",
                  "czestnr1",
                  "czestnr2",
                  "czestnr"),
    col = c("black","blue","red","green"),
    lty = c(1, 2, 2, 2))



```

czestotliwosc numer 1 -> wybor rzedu ruchomej sredniej ( parametr q)
(czerwona najbardziej optymalna)

Dekompozycja na podstawie ruchomej sredniej


obrazeknumer2
```{r}
#dekompozycja addytywna
srednie_wartosci_miesieczne_BTC.dekomp.add <- decompose(srednie_wartosci_miesieczne_BTC, type = "additive")

#wykresy skladowych
plot(srednie_wartosci_miesieczne_BTC.dekomp.add)
```



```{r}

#dekompozycja addytywna
srednie_wartosci_miesieczne_LSK.dekomp.add <- decompose(srednie_wartosci_miesieczne_LSK, type = "additive")

#wykresy skladowych
plot(srednie_wartosci_miesieczne_LSK.dekomp.add)

```


Wydobycie poszczególnych składowych 

```{r}
srednie_wartosci_miesieczne_LSK.dekomp.add.trend <- srednie_wartosci_miesieczne_LSK.dekomp.add$trend
srednie_wartosci_miesieczne_LSK.dekomp.add.sezonowosc <- srednie_wartosci_miesieczne_LSK.dekomp.add$seasonal
srednie_wartosci_miesieczne_LSK.dekomp.add.ind.sezon <- srednie_wartosci_miesieczne_LSK.dekomp.add$figure
srednie_wartosci_miesieczne_LSK.dekomp.add.reszty <-srednie_wartosci_miesieczne_LSK.dekomp.add$random


```



```{r}
library(xts)
library(forecast)
```



```{r}
#wykres współczynników sezonowych
barplot(srednie_wartosci_miesieczne_LSK.dekomp.add.ind.sezon, 
        names.arg = month.abb, main = "indesky sezonowe")

#wykres reszt
tsdisplay(srednie_wartosci_miesieczne_LSK.dekomp.add.reszty, main = "losowe fluktuacje")
#blad

```



Wczesniej wariancja wieksza na poczatku i na koncu, wiec porownamy z modelem dekompozycji multiplikatywnej






```{r}
#dekompozycja addytywna

srednie_wartosci_miesieczne_LSK.dekomp.add <- decompose(srednie_wartosci_miesieczne_LSK, type = "additive")


#dekompozycja multiplikatywna

srednie_wartosci_miesieczne_LSK.dekomp.mult <- decompose(srednie_wartosci_miesieczne_LSK, type = "multiplicative")


#wykresy skłądowych

plot(srednie_wartosci_miesieczne_LSK.dekomp.add)
plot(srednie_wartosci_miesieczne_LSK.dekomp.mult)


```












Dekompozycja na podstawie modelu regresji: trend liniowy + sezonowosc

1. Kodowanie sezonowości
```{r}
head(seasonaldummy(srednie_wartosci_miesieczne_LSK), 12)
```





```{r}
#dopasowanie trendu liniowego
srednie_wartosci_miesieczne_LSK.tslm.trend <- tslm(srednie_wartosci_miesieczne_LSK ~ trend)

summary(srednie_wartosci_miesieczne_LSK.tslm.trend)
```



```{r}
#dane i dopasowany trend liniowy

plot(srednie_wartosci_miesieczne_LSK, main = "Dekomp na podstawie regresji liniowej")
lines(fitted(srednie_wartosci_miesieczne_LSK.tslm.trend), col ="green",lty=2)
legend("topleft", legend = c("oryginalne dane", "trend liniowy"),
       col = c("black","green"),lty = c(1, 2))


#wykres reszt
tsdisplay(residuals(srednie_wartosci_miesieczne_LSK.tslm.trend), main = "reszty losowe")




```






Dodamy sezonowosc , moze ona da nam lepsze wyniki



```{r}
srednie_wartosci_miesieczne_LSK.tslm.trend.sezonowosc <- tslm(srednie_wartosci_miesieczne_LSK ~ trend + season)


summary(srednie_wartosci_miesieczne_LSK.tslm.trend.sezonowosc)
```



```{r}
plot(srednie_wartosci_miesieczne_LSK, main = "Dekomp na podstawie regresji liniowej", col = "black")

lines(fitted(srednie_wartosci_miesieczne_LSK.tslm.trend.sezonowosc), col ="green",lty=2)

legend("topleft", legend = c("oryginalne dane", "trend + sezonowosc"),
       col = c("black","green"),lty = c(1, 2))


#wykres reszt
tsdisplay(residuals(srednie_wartosci_miesieczne_LSK.tslm.trend.sezonowosc))
```










```{r}
#dekompozycja dla danych zlogarytmizowanych
#transformacja Boxa-Coxa z lambda=0

srednie_wartosci_miesieczne_LSK.log.tslm <- tslm(srednie_wartosci_miesieczne_LSK ~ trend + season, lambda = 0)

summary(srednie_wartosci_miesieczne_LSK.log.tslm)



```







```{r}
plot(srednie_wartosci_miesieczne_LSK, main = "Dekomp na podstawie regresji liniowej n , dane zlogarytmowane", col = "black")

lines(fitted(srednie_wartosci_miesieczne_LSK.log.tslm), col ="green",lty=2)

legend("topleft", legend = c("oryginalne dane", "trend + sezonowosc"),
       col = c("black","green"),lty = c(1, 2))


#wykres reszt
tsdisplay(residuals(srednie_wartosci_miesieczne_LSK.log.tslm))
```




Dekompozycja  na podstawie modelu regresji: trend wielomianowy + sezonowość

zamiast liniowego -> trend wielomianowy





```{r}


#trend kwadratowy

srednie_wartosci_miesieczne_LSK.log.tslm.2 <- tslm(srednie_wartosci_miesieczne_LSK ~ season + trend + I(trend ^ 2), lambda =0)
#trend wielomianowy stopnia 4

srednie_wartosci_miesieczne_LSK.log.tslm.4 <- tslm(srednie_wartosci_miesieczne_LSK ~ season + poly(trend, raw = TRUE, degree = 4), lambda = 0)


```



```{r}
summary(srednie_wartosci_miesieczne_LSK.log.tslm.2)
```




```{r}
summary(srednie_wartosci_miesieczne_LSK.log.tslm.4)
```












```{r}
plot(srednie_wartosci_miesieczne_LSK, main = "Dekomp na podstawie regresji liniowej n , dane zlogarytmowane", col = "black")

lines(fitted(srednie_wartosci_miesieczne_LSK.log.tslm.2), col ="green",lty=2)

legend("topleft", legend = c("oryginalne dane", "trend + sezonowosc"),
       col = c("black","green"),lty = c(1, 2))


#wykres reszt
tsdisplay(residuals(srednie_wartosci_miesieczne_LSK.log.tslm.2))
```





```{r}
plot(srednie_wartosci_miesieczne_LSK, main = "Dekomp na podstawie regresji liniowej n , dane zlogarytmowane", col = "black")

lines(fitted(srednie_wartosci_miesieczne_LSK.log.tslm.4), col ="green",lty=2)

legend("topleft", legend = c("oryginalne dane", "trend + sezonowosc"),
       col = c("black","green"),lty = c(1, 2))


#wykres reszt
tsdisplay(residuals(srednie_wartosci_miesieczne_LSK.log.tslm.4))
```






```{r}
#Kryteria informacyjne  do wyboru modelu AIC BIC itp

AIC(srednie_wartosci_miesieczne_LSK.log.tslm, srednie_wartosci_miesieczne_LSK.log.tslm.2, srednie_wartosci_miesieczne_LSK.log.tslm.4)



BIC(srednie_wartosci_miesieczne_LSK.log.tslm, srednie_wartosci_miesieczne_LSK.log.tslm.2, srednie_wartosci_miesieczne_LSK.log.tslm.4)



```


```{r}
#analiza wariancji
anova(srednie_wartosci_miesieczne_LSK.log.tslm, srednie_wartosci_miesieczne_LSK.log.tslm.2, srednie_wartosci_miesieczne_LSK.log.tslm.4)
```





Eliminacja trendu i sezonowosci z danych





```{r}
#dekompozycja z wykorzystaniem decompose()
srednie_wartosci_miesieczne_LSK.log.dekomp.add <- decompose(log(srednie_wartosci_miesieczne_LSK), type = "additive")


#szereg reszt
reszty.decompose <- srednie_wartosci_miesieczne_LSK.log.dekomp.add$random
plot (reszty.decompose, main = paste("Dekompozycja z wykorzystaniem decompose, szereg reszt"))
```



```{r}
#dekompozycja z wykorzystaniem tslm()
srednie_wartosci_miesieczne_LSK.log.tslm <- tslm(srednie_wartosci_miesieczne_LSK ~ trend + season, lambda=0)

#szereg reszt
reszty.tslm <- residuals(srednie_wartosci_miesieczne_LSK.log.tslm)
plot(reszty.tslm, 
     main = paste("Dekompozycja na podstawie tslm, szereg reszt"))


```






```{r}
#dekompozycja klasyczna(decompose)

srednie_wartosci_miesieczne_LSK.dekomp.mult <- decompose(srednie_wartosci_miesieczne_LSK, "multiplicative")

#eliminacja sezonowosci

srednie_wartosci_miesieczne_LSK.odsezonowane <- seasadj(srednie_wartosci_miesieczne_LSK.dekomp.mult)


plot(srednie_wartosci_miesieczne_LSK, main = "Dane oryginalne i odsezonowane", col = "black")

lines(srednie_wartosci_miesieczne_LSK.odsezonowane, col ="green",lty=2)

legend("topleft", legend = c("oryginalny szereg", "szereg odsezonowany"),
       col = c("black","green"))




```




Przyklady:
```{r}
#AR(4)

AR4.sim <- 
  arima.sim(n = 200, model = list(order = c(4, 0, 0),
                                         ar = c(.8, -.4, .3, .2)))

#AR(1) ze zlymi parametrami (nie spelnia warunkow stacjonarnosci)

AR4.sim <- 
  arima.sim(n = 200, model = list(order = c(1, 0, 0),
                                         ar = 1))


```


```{r}
#AR(2, 1)

ARMA21.sim <- 
  arima.sim(n = 200, model = list(order = c(2, 0, 1),
                                         ar = c(.8, -.4), ma = .7))

# ARMIMA(0,1,1)

ARIMA011.sim <- 
  arima.sim(n = 199, model = list(order = c(0, 1, 1),
                                         ma = .9))
```




```{r}
plot(AR4.sim)
plot(ARMA21.sim)
plot(ARIMA011.sim)


```



Przygotowanie danych

```{r}
#eliminacja sezonowosci
srednie_wartosci_miesieczne_LSK.diff12 <- diff(srednie_wartosci_miesieczne_LSK, 12)

tsdisplay(srednie_wartosci_miesieczne_LSK.diff12) # czy mamy szereg stacjonarny?
#nie bo PACF bliskie 1 i duze wartosci ACF!

```




```{r}
#Dane po zroznicowaniu z opoznieniem sezonowym 12 i zroznicowaniu z opoznieniem 1
#roznicowanie z opozniemiem 1
srednie_wartosci_miesieczne_LSK.diff12.diff1 <- diff(srednie_wartosci_miesieczne_LSK.diff12)

tsdisplay(srednie_wartosci_miesieczne_LSK.diff12.diff1)
```







Identyfikacja modelu MA(q)



```{r}
#ACF dla LSK
#po zroznicowaniu z opoznieniem 12 oraz opoznieniem 1
Acf(srednie_wartosci_miesieczne_LSK.diff12.diff1)

```

Identyfikacja modelu AR(p) dla LSK


```{r}
Pacf(srednie_wartosci_miesieczne_LSK.diff12.diff1)
```


Ciag dalszy



```{r}
srednie_wartosci_miesieczne_LSK.diff12.diff1 <- diff(diff(srednie_wartosci_miesieczne_LSK,12),1)

#ustalony rzad np 13 (przyklad jest to sprzeczne z naszymi szacowaniami!)
p <- 13

#metoda Yule`a-Walkera (domyślna)
AR.model.yw <- ar(srednie_wartosci_miesieczne_LSK.diff12.diff1,
                  order.max = p, aic = FALSE)
print(AR.model.yw)

```



```{r}
#MNW(mle)
AR.model.mle <- ar(srednie_wartosci_miesieczne_LSK.diff12.diff1,
                   order.max = p, aic = FALSE,
                   method="mle")
print(AR.model.mle)
```


```{r}
#automatyczny wybor optymalnego rzedu (min AIC)
AR.optymalny.aic <- ar(srednie_wartosci_miesieczne_LSK.diff12.diff1, aic = TRUE)
print(AR.optymalny.aic)
```

na podstawie obliczen wyzej wybieram AR(1), ale warto rowniez sprwdzic AR(2), widac, ze przyklad wyzej p =13 AR(13) nie ma sensu



```{r}
#podglad na rozbieznosci
#wykres kryterium AIC dla roznych rzedow p
AR.aic <- AR.optymalny.aic$aic
print(AR.aic)

```



```{r}
plot(as.numeric(names(AR.aic)), AR.aic,
     xlab = "rzad modelu autoregresji (p)", ylab = "AIC(p)",
     main = "porownanie kryterium AIC", type = "b")
grid()
```



Przyklad z dopasowaniem modelu ARIMA


```{r}
# model 1: ARIMA(0,1,12) (0,1,0)
ARIMA.model1 <- Arima(srednie_wartosci_miesieczne_LSK, order = c(0, 1, 12),
                      seasonal = list(order = c(0, 1, 0),
                                      peroid = 12))

summary(ARIMA.model1)
```

```{r}
# model 2: ARIMA(13,1,0) (0,1,0)
ARIMA.model2 <- Arima(srednie_wartosci_miesieczne_LSK, order = c(13,1,0),
                      seasonal = list(order = c(0, 1, 0),
                                      peroid = 12))

summary(ARIMA.model2)

```




Analiza reszt i testy statystyczne

Diagnostyka modeli dopasowan 

```{r}
# przeksztalcenie do postaci stacjonarnej
srednie_wartosci_miesieczne_LSK.diff12.diff1 <- diff(diff(srednie_wartosci_miesieczne_LSK, 12), 1)

#dopasowanie modelu AR
AR1 <- ar(srednie_wartosci_miesieczne_LSK.diff12.diff1) #rzad wybrany za odpowiedni
AR13 <- ar(srednie_wartosci_miesieczne_LSK.diff12.diff1, aic = FALSE, order.max=13)

#wyznaczenie reszt z modelu
AR1.reszty <- AR1$resid
AR13.reszty <- AR13$resid

head(AR1.reszty, 15)



```


```{r}
head(AR13.reszty, 15)
```


```{r}
#AR optymalny: wykres reszt i ACF
plot(AR1.reszty,
     main = "AR(1) wykres wartosci resztowych")
Acf(AR1.reszty, lag.max = 30,
    main = "AR(1): ACF dla reszt", ylim =c(-0.3, 0.3))

#AR(13): wykres reszt i ACF
plot(AR13.reszty,
     main = "AR(31) wykres wartosci resztowych")
Acf(AR13.reszty, lag.max = 30,
    main = "AR(13): ACF dla reszt", ylim =c(-0.3, 0.3))

```




brak regularnych wzorców
DM1
Badanie losowosci reszt

```{r}
Box.test(AR1.reszty, lag =1, type = "Ljung-Box")
```



```{r}
Box.test(AR1.reszty, lag =12, type = "Ljung-Box", fitdf=1)
```





```{r}
Box.test(AR1.reszty, lag =24, type = "Ljung-Box", fitdf=1)

```





```{r}
#test dla reszt z modelu AR(13)
Box.test(AR13.reszty, lag =1, type = "Ljung-Box")

```



```{r}
Box.test(AR13.reszty, lag =12, type = "Ljung-Box")

```


```{r}
Box.test(AR13.reszty, lag =24, type = "Ljung-Box", fitdf=13)

```



Własnosci reszt dla modelu 12


```{r}
ARIMA.model <- Arima(srednie_wartosci_miesieczne_LSK, order = c(0,1,12),
                     seasonal = list(order=c(0,1,0),
                                     period = 12))

#wykresy diagnostyczne (max opoznienie = 24)
tsdiag(ARIMA.model, gof.lag = 24)
```






Inne Dodatkowe narzedzia do testu losowosci


```{r}
ARIMA.reszty <- residuals(ARIMA.model)

#test losowosci reszt
Box.test(ARIMA.reszty, type = "Ljung-Box", lag = 1)
```



```{r}
Box.test(ARIMA.reszty, type = "Ljung-Box", lag = 12)

```





```{r}
Box.test(ARIMA.reszty, type = "Ljung-Box", lag = 24, fitdf=12)

```



```{r}
#analiza normalnosci reszt - histogram
hist(ARIMA.reszty, main = "histogram")

#analiza normalnosci reszt - wykres kwantylowy
qqnorm(ARIMA.reszty, main="wykres kwantylowy")
qqline(ARIMA.reszty)
```




```{r}
#analiza normalnosci reszt- test zgodnosci
shapiro.test(ARIMA.reszty)                                                                                                                                                                                                                                                                                                                                                 
```




```{r}
#porownanie kryteriow dobroci dopasowania (AIC, AICC, BIC)

model1 <- Arima(srednie_wartosci_miesieczne_LSK, order = c(1, 1, 0),
                seasonal = list(order = c(0, 1, 0)))

model2 <- Arima(srednie_wartosci_miesieczne_LSK, order = c(13, 1, 0),
                seasonal = list(order = c(0, 1, 0)))

model3 <- Arima(srednie_wartosci_miesieczne_LSK, order = c(0, 1, 12),
                seasonal = list(order = c(0, 1, 0)))

model4 <- Arima(srednie_wartosci_miesieczne_LSK, order = c(1, 1, 1),
                seasonal = list(order = c(0, 1, 0)))

```


```{r}
summary(model1)
```



```{r}
summary(model2)
```





```{r}
summary(model3)
```




```{r}
summary(model4)
```


Wyznaczamy wspolczynniki istotne

```{r}
#oszacowane wspolczynniki i ich s
coef <- model2$coef
coef.std <- sqrt(diag(model2$var.coef))

#statystyki dla testu istotnosci
ratios <- coef / (1.96 * coef.std)

#indeksy istotnych wspolczynnikow
istotne <- which(abs(ratios) >= 1)
istotne
```


```{r}
#wektor z informacja o istotnosci
model2.fixed <- numeric(13) #l wspolczynnikow modelu
model2.fixed[istotne] <- NA

#dopasowanie modelu z pomienieciem nieistotnych wspolczynnikow
model2.subset <- Arima(srednie_wartosci_miesieczne_LSK, order = c(13, 1 ,0),
                       seasonal = list(order=c(0, 1, 0)),
                       fixed = model2.fixed)

#porownanie AICC i BIC dla obu modeli
model2$aicc - model2.subset$aicc
```



```{r}
model2$bic - model2.subset$bic
```


wszytsko minus wszystko czyli 0


Teraz wybor optymalnego rzedu roznicowania


```{r}
#wybor optymalnego rzedu roznicowania na podstawie testow statystycznych

#optymalny rzad roznicowania z opoznieniem 1

d.opt <- ndiffs(srednie_wartosci_miesieczne_LSK)
d.opt
```



```{r}
#optymalny rzad roznicownaia z opoznieniem sezonowym

D.opt <- nsdiffs(srednie_wartosci_miesieczne_LSK)
D.opt
```


Automatyczny wybor modelu


```{r}
#optymalny wzgledem AIC
arima.optym.AIC <- auto.arima(srednie_wartosci_miesieczne_LSK, ic = "aic")
arima.optym.AIC
```



```{r}
#optymalny wzgledem AIC
arima.optym.AICC <- auto.arima(srednie_wartosci_miesieczne_LSK, ic = "aicc")
arima.optym.AICC
```




```{r}
#optymalny wzgledem AIC
arima.optym.BIC <- auto.arima(srednie_wartosci_miesieczne_LSK, ic = "bic")
arima.optym.BIC
```



PROGNOZOWANIE
1.Prosta ruchoma średnia

```{r}
#dla naszych danych, gdzie mamy widoczny trend długoterminowy
srednie_wartosci_miesieczne_LSK.forecast.mean <- meanf(x = srednie_wartosci_miesieczne_LSK, h =20)
srednie_wartosci_miesieczne_LSK.forecast.mean
```



```{r}
plot(srednie_wartosci_miesieczne_LSK.forecast.mean, main ="LSK prognoza na podstawie sredniej")
```




```{r}
#dla danych zroznicowanych (po usunieciu trendu)
srednie_wartosci_miesieczne_LSK.diff.forecast.mean <- meanf(x = diff(srednie_wartosci_miesieczne_LSK), h=20)
plot(srednie_wartosci_miesieczne_LSK.diff.forecast.mean,
     main = paste("Prognoza dla szeregu LSK po zroznicownaiu z opoznieniem 1"))


#dla danych zroznicowanych (po usunieciu trendu i sezonowosci)
srednie_wartosci_miesieczne_LSK.diff.forecast.mean2 <- meanf(x = diff(srednie_wartosci_miesieczne_LSK, 12), h=20)
plot(srednie_wartosci_miesieczne_LSK.diff.forecast.mean2,
     main = paste("Prognoza dla szeregu LSK po zroznicownaiu z opoznieniem 12"))



```

Metoda naiwna

```{r}
#meotda naiwna
srednie_wartosci_miesieczne_LSK.forecast.naive <- naive(x = srednie_wartosci_miesieczne_LSK, h =20)
srednie_wartosci_miesieczne_LSK.forecast.naive



```


```{r}
plot(srednie_wartosci_miesieczne_LSK.forecast.naive,
     main = "LSK naive random walk forecast")

#sezonowa metoda naiwna
srednie_wartosci_miesieczne_LSK.forecast.snaive <- naive(x = srednie_wartosci_miesieczne_LSK, h =24)
srednie_wartosci_miesieczne_LSK.forecast.snaive

```


```{r}
plot(srednie_wartosci_miesieczne_LSK.forecast.snaive,
     main = "LSK seasonal naive forecast")
```



Metoda uwzgledniajaca dryf


```{r}
#dane z trendem
srednie_wartosci_miesieczne_LSK.forecast.rwf <- rwf(x=srednie_wartosci_miesieczne_LSK, drift= TRUE, h=20)
plot(srednie_wartosci_miesieczne_LSK.forecast.rwf, main = "LSK prognozy na podstawie bladzenia losowego z dryfem")


#dla danych sezonowych
srednie_wartosci_miesieczne_LSK.forecast.rwf2 <- rwf(x=srednie_wartosci_miesieczne_LSK, drift= TRUE, h=24)
plot(srednie_wartosci_miesieczne_LSK.forecast.rwf2, main = "LSK prognozy na podstawie bladzenia losowego z dryfem")
```



dla danych zlogarytmizowanych

```{r}
log.srednie_wartosci_miesieczne_LSK.forecast.rwf <- rwf(x = BoxCox(srednie_wartosci_miesieczne_LSK, lambda = 0),
                                                        drigr = TRUE, h =20)

plot(log.srednie_wartosci_miesieczne_LSK.forecast.rwf, 
     main= "log(LSK) prognozy na podstawie bladzenia losowego z dryfem")






#dla danych oryginalnych z uwzglednieniem transforacji logarytmicznej (Box-Coxa z lambda =0)
srednie_wartosci_miesieczne_LSK.forecast.log.rwf <- rwf(x=srednie_wartosci_miesieczne_LSK, drift = TRUE, h =20, lambda = 0)

plot(srednie_wartosci_miesieczne_LSK.forecast.log.rwf, 
     main= "LSK prognozy na podstawie bladzenia losowego z dryfem")

```




Porownanie dokladnosci prognoz

```{r}
f1 <- meanf(srednie_wartosci_miesieczne_LSK, h=20)
f2 <- naive(srednie_wartosci_miesieczne_LSK, h=20)
f3 <- rwf(srednie_wartosci_miesieczne_LSK, drift=TRUE, h=20)
f4 <- rwf(srednie_wartosci_miesieczne_LSK, drift = TRUE, h=20, lambda = 0)

#porownanie dokladnosci
accuracy.f1 <- accuracy(f1)
accuracy.f2 <- accuracy(f2)
accuracy.f3 <- accuracy(f3)
accuracy.f4 <- accuracy(f4)
```





```{r}
accuracy.f1
```

```{r}
accuracy.f2
```

```{r}
accuracy.f3
```

```{r}
accuracy.f4
```



Przedzialy predykcyjne


```{r}
#95% przedzialy predykcyjne
srednie_wartosci_miesieczne_LSK.forecast.rwf <- rwf(srednie_wartosci_miesieczne_LSK,
                                                    drift = TRUE, h=20,level=0.95)

plot(srednie_wartosci_miesieczne_LSK.forecast.rwf)
```





```{r}
#80% i 95% przedzialy prefykcyjne na jednym wykresie
srednie_wartosci_miesieczne_LSK.forecast.rwf.1 <- rwf(srednie_wartosci_miesieczne_LSK, drift = TRUE, h=20,
                                                      level = c(0.8, 0.95))


plot(srednie_wartosci_miesieczne_LSK.forecast.rwf.1,
     main = paste("Przedzialy predykcyjne na poziomie ufnosci 80% i 95%"))
```




```{r}
#wykresy wachlarzowe (fanplot)
srednie_wartosci_miesieczne_LSK.forecast.rwf.2 <- rwf(srednie_wartosci_miesieczne_LSK, drift=TRUE,
                                                      h=20, fan= TRUE)
plot(srednie_wartosci_miesieczne_LSK.forecast.rwf.2,
     main = paste("Wykres wachlarzowy"))


```




Podział danych na czesc uczaca i testowa


```{r}
#dyielimz dane na cyesc ucyaca i testow
srednie_wartosci_miesieczne_LSK.train <- window(srednie_wartosci_miesieczne_LSK, end = c(2018, 6))

length(srednie_wartosci_miesieczne_LSK.train)


```



```{r}
srednie_wartosci_miesieczne_LSK.test <- window(srednie_wartosci_miesieczne_LSK, start = c(2018, 7))
length(srednie_wartosci_miesieczne_LSK.test)
```


 27+5= 32

```{r}
srednie_wartosci_miesieczne_LSK.sprawdzenieczydziala <- window(srednie_wartosci_miesieczne_LSK, start = c(2016, 4))
length(srednie_wartosci_miesieczne_LSK.sprawdzenieczydziala)
```



```{r}
#wyznaczam prognozy dla kolejnych miesiecy na bazie danych uczacych

f1 <- meanf(srednie_wartosci_miesieczne_LSK.train, h=25)
f2 <- naive(srednie_wartosci_miesieczne_LSK.train, h=25)
f3 <- rwf(srednie_wartosci_miesieczne_LSK.train, drift = TRUE, h=25)
f4 <- rwf(srednie_wartosci_miesieczne_LSK.train, drift = TRUE, h=25, lambda=0)

```



```{r}
#porownanie prognoz i wartosci rzeczywistych
y.zakres <- c(0.9, 1.1) * range(srednie_wartosci_miesieczne_LSK, srednie_wartosci_miesieczne_LSK.test)
par(mfrow = c(4, 1))

plot(f1, ylim = y.zakres)
lines(srednie_wartosci_miesieczne_LSK.test, col ="red", lty = 2)
plot(f2, ylim = y.zakres)
lines(srednie_wartosci_miesieczne_LSK.test, col ="red", lty = 2)
plot(f3, ylim = y.zakres)
lines(srednie_wartosci_miesieczne_LSK.test, col ="red", lty = 2)
plot(f4, ylim = y.zakres)
lines(srednie_wartosci_miesieczne_LSK.test, col ="red", lty = 2)
```


```{r}
#dokladnosc prognoz dla danych uczacych i testowych

kryteria <- c("MAE","RMSE","MAPE","MASE")

acc.f1.test <- accuracy(f1, srednie_wartosci_miesieczne_LSK.test)[, kryteria]
acc.f2.test <- accuracy(f2, srednie_wartosci_miesieczne_LSK.test)[, kryteria]
acc.f3.test <- accuracy(f3, srednie_wartosci_miesieczne_LSK.test)[, kryteria]
acc.f4.test <- accuracy(f4, srednie_wartosci_miesieczne_LSK.test)[, kryteria]


acc.f1.test





```




```{r}
acc.f2.test
```

```{r}
acc.f3.test
```

```{r}
acc.f4.test
```


```{r}
#wyznaczam reszty 
reszty.1 <- residuals(f1)
reszty.2 <- residuals(f2)
reszty.3 <- residuals(f3)
```






```{r}
#wykres reszt
par(mfrow=c(3, 1))
plot(reszty.1)
plot(reszty.2)
plot(reszty.3)


```



```{r}
#ACF i histogramy dla reszt
par(mfrow = c(3, 2))
Acf (reszty.1, lag.max = 30)
hist(reszty.1)
Acf (reszty.2, lag.max = 30)
hist(reszty.2)
Acf (reszty.3, lag.max = 30)
hist(reszty.3)


```


```{r}
#losowosc reszt
Box.test(reszty.1, lag=10, type="Ljung-Box")
```




```{r}
Box.test(reszty.2, lag=10, type="Ljung-Box")

```



```{r}
Box.test(reszty.3, lag=10, type="Ljung-Box")

```


odrzucam hipotezy o losowosci reszt



MODELE KLASY ARIMA- prognozowanie



```{r}
#przekształcamy dane do postaci stacjonarnej, roznicujemy z opoznieniem 12 i opzonieniem 1
srednie_wartosci_miesieczne_LSK.diff12 <- diff(srednie_wartosci_miesieczne_LSK, 12)
srednie_wartosci_miesieczne_LSK.diff12.diff1 <-diff(srednie_wartosci_miesieczne_LSK, 1)

tsdisplay(srednie_wartosci_miesieczne_LSK.diff12.diff1)

```





```{r}
# model ARIMA(13,1,0)(0,1,0)
ARIMA.model1 <- Arima(srednie_wartosci_miesieczne_LSK,
                      order = c(13, 1, 0), seasonal = c(0, 1, 0))
# model ARIMA(0,1,12)(0,1,0)
ARIMA.model2 <- Arima(srednie_wartosci_miesieczne_LSK,
                      order = c(0, 1, 12), seasonal = c(0, 1, 0))
# model ARIMA(1,1,1)(0,1,0)
ARIMA.model3 <- Arima(srednie_wartosci_miesieczne_LSK,
                      order = c(1, 1, 1), seasonal = c(0, 1, 0))

# model ARIMA(0,1,1)(0,1,0)
ARIMA.model4 <- Arima(srednie_wartosci_miesieczne_LSK,
                      order = c(0, 1, 1), seasonal = c(0, 1, 0))

#prognozy
ARIMA.model1.prognozy <- forecast(ARIMA.model1, h=24)
ARIMA.model2.prognozy <- forecast(ARIMA.model2, h=24)
ARIMA.model3.prognozy <- forecast(ARIMA.model3, h=24)
ARIMA.model4.prognozy <- forecast(ARIMA.model4, h=24)

#pogdlad prognoz
ARIMA.model1.prognozy$mean #prognozy punktowe



```


```{r}
ARIMA.model1.prognozy$upper
```


```{r}
ARIMA.model1.prognozy$lower
```



```{r}
ARIMA.model1.prognozy

```



```{r}
#lista skladowych w ynikowej liscie
names(ARIMA.model1.prognozy)
```


```{r}
par(mfrow = c(3, 1))
plot(ARIMA.model1.prognozy)
plot(ARIMA.model2.prognozy)
plot(ARIMA.model3.prognozy)
plot(ARIMA.model4.prognozy)


```





```{r}
#porownanie prognozy na jednym wykresie
ts.plot(ARIMA.model1.prognozy$mean,
        ARIMA.model2.prognozy$mean,
        ARIMA.model3.prognozy$mean,
        ARIMA.model4.prognozy$mean,
        main = "Porównanie prognoz dla LSK",
        col = c("black","red","green"))
grid()
legend("topright",
       legend=c("model ARIMA(13,1,0)(0,1,0)","model ARIMA(0,1,12)(0,1,0)","model ARIMA(1,1,1)(0,1,0)","model ARIMA(0,1,1)(0,1,0)"),
       col =c("black","red","green","yellow"), bg="white")
```




```{r}
#dokladnosc prognoz dla zbioru uczacego
kryteria <- c("MAE","RMSE","MAPE","MASE")

accuracy(ARIMA.model1.prognozy)[, kryteria]
```


```{r}
accuracy(ARIMA.model2.prognozy)[, kryteria]

```

```{r}
accuracy(ARIMA.model3.prognozy)[, kryteria]

```

```{r}
accuracy(ARIMA.model4.prognozy)[, kryteria]

```




Automatyczna kosntrukcja prognoz

```{r}
#dopasowanie modelu ARIMA
srednie_wartosci_miesieczne_LSK.ARIMA <- auto.arima(srednie_wartosci_miesieczne_LSK)
srednie_wartosci_miesieczne_LSK.ARIMA
```

ARIMA(0, 1, 1) 


```{r}
#prognozy i przedzialy predykcyjne
srednie_wartosci_miesieczne_LSK.prognozy <- forecast(srednie_wartosci_miesieczne_LSK.ARIMA, h=24, fan = TRUE)
```




```{r}
#wykresy prognoz
par(mfrow=c(2,2))
plot(srednie_wartosci_miesieczne_LSK.prognozy, ylab = "srednie_wartosci_miesieczne_LSK")
```




```{r}
#wykresy prognoz

plot(srednie_wartosci_miesieczne_LSK.prognozy, ylab = "srednie_wartosci_miesieczne_LSK")
```


Proste wygladzenie wykladnicze (SES)

```{r}
#prognozy na podstawie algorytmu SES
srednie_wartosci_miesieczne_LSK.ses.1 <- ses(srednie_wartosci_miesieczne_LSK, alpha = 0.2, initial = "simple", h=6)

srednie_wartosci_miesieczne_LSK.ses.2 <- ses(srednie_wartosci_miesieczne_LSK, alpha = 0.5, initial = "simple", h=6)

srednie_wartosci_miesieczne_LSK.ses.3 <- ses(srednie_wartosci_miesieczne_LSK, h=6)

alpha.optimal <- srednie_wartosci_miesieczne_LSK.ses.3$model$par[1]
alpha.optimal


```


```{r}
#porownanie dopasowania
plot(srednie_wartosci_miesieczne_LSK.ses.1, plot.conf = FALSE,
     col = "black", fcol = "white",
     ylab = "srednie_wartosci_miesieczne_LSK")
lines(fitted(srednie_wartosci_miesieczne_LSK.ses.1), col = "blue", lty = 2)
lines(fitted(srednie_wartosci_miesieczne_LSK.ses.2), col = "red", lty = 2)
lines(fitted(srednie_wartosci_miesieczne_LSK.ses.3), col = "green", lty = 2)
abline(v = end(srednie_wartosci_miesieczne_LSK)[1], lty=3)

#porownanie prognoz
lines(srednie_wartosci_miesieczne_LSK.ses.1$mean, col = "blue", lty = 2)
lines(srednie_wartosci_miesieczne_LSK.ses.2$mean, col = "red", lty = 2)
lines(srednie_wartosci_miesieczne_LSK.ses.3$mean, col = "green", lty = 2)

legend("topleft",
       legend = c("oryginalny szereg",
                  "SES a=0.2","SES a=0.5", 
                  paste("SES: alpha = ",
                        format(alpha.optimal, digits = 2))),
       col = c("black","blue","red","green"),
       lty = 1:4, bg = "white")


```




```{r}
plot(srednie_wartosci_miesieczne_LSK.ses.3)
```






```{r}
summary(srednie_wartosci_miesieczne_LSK.ses.3)
```












































Metoda Holta

```{r}
srednie_wartosci_miesieczne_LSK.holt <- holt(srednie_wartosci_miesieczne_LSK, h=20)
srednie_wartosci_miesieczne_LSK.holt
```


```{r}
plot(srednie_wartosci_miesieczne_LSK.holt)
```



```{r}
summary(srednie_wartosci_miesieczne_LSK.holt)
```



```{r}
srednie_wartosci_miesieczne_LSK.holt <- holt(srednie_wartosci_miesieczne_LSK, h=20)
srednie_wartosci_miesieczne_LSK.holt.damped <- holt(srednie_wartosci_miesieczne_LSK, h=20, damped = TRUE)
srednie_wartosci_miesieczne_LSK.holt.exp <- holt(srednie_wartosci_miesieczne_LSK, h=20, exponential = TRUE)


#wykresy prognoz
par(mfrow = c(3, 1))
plot(srednie_wartosci_miesieczne_LSK.holt)
plot(srednie_wartosci_miesieczne_LSK.holt.damped)
plot(srednie_wartosci_miesieczne_LSK.holt.exp)





```




```{r}
kryteria <- c("MAE","RMSE","MAPE","MASE")
accuracy(srednie_wartosci_miesieczne_LSK.holt)[, kryteria]
```



```{r}
accuracy(srednie_wartosci_miesieczne_LSK.holt.damped)[, kryteria]

```


```{r}
accuracy(srednie_wartosci_miesieczne_LSK.holt.exp)[, kryteria]

```




PRÓBA 1


```{r}
tsdisplay(srednie_wartosci_miesieczne_LSK)

```



```{r}
library(urca)
```


```{r}

adf123 <- ur.df(y=srednie_wartosci_miesieczne_LSK, lags=1, type='trend')
#0.09644 przy 12 lags 0
summary(adf123)
```




```{r}
plot(srednie_wartosci_miesieczne_BTC)
```


```{r}
BTC_box <- BoxCox(srednie_wartosci_miesieczne_BTC, lambda = 0)
BTC_box
```



```{r}
plot(BTC_box)
```


```{r}
adfprzed <- ur.df(y=srednie_wartosci_miesieczne_BTC, lags=0, type='trend')

summary(adfprzed)
```



```{r}
adfpo <- ur.df(y=BTC_box, lags=0, type='trend')

summary(adfpo)
```

```{r}
library(tseries)
```

```{r}
adf.test(srednie_wartosci_miesieczne_BTC)
```


```{r}
tsdisplay(srednie_wartosci_miesieczne_BTC)
```

```{r}
BTC_box <- BoxCox(srednie_wartosci_miesieczne_BTC, lambda = 0)
BTC_box
tsdisplay(BTC_box)
```


```{r}
adf.test(BTC_box)
```


```{r}
BTC_box.diff1 <- diff(BTC_box, 1)

tsdisplay(BTC_box.diff1)
```


```{r}
adf.test(BTC_box.diff1)
```
```{r}
BTC_box.diff1.diff1 <- diff(BTC_box.diff1, 1)

tsdisplay(BTC_box.diff1.diff1)
```

```{r}
adf.test(BTC_box.diff1.diff1)


```




```{r}

#optymalny wzgledem AIC
arima.optymalnyy.AIC <- auto.arima(BTC_box.diff1.diff1, ic = "aic")
arima.optymalnyy.AIC

```



```{r}
arima.optymalnyy.AIC.prognozy <- forecast(arima.optymalnyy.AIC, h=24, fan = TRUE)

```



```{r}
plot(arima.optymalnyy.AIC.prognozy, ylab = "BTC")

```









```{r}
adf.test(srednie_wartosci_miesieczne_LSK)
```

```{r}
adf.test(srednie_wartosci_miesieczne_LSK.diff12)
```

```{r}
adf.test(srednie_wartosci_miesieczne_LSK.diff12.diff1)
```




TEST

```{r}
#dekompozycja addytywna

srednie_wartosci_miesieczne_BTC.dekomp.add <- decompose(srednie_wartosci_miesieczne_BTC, type = "additive")


#dekompozycja multiplikatywna

srednie_wartosci_miesieczne_BTC.dekomp.mult <- decompose(srednie_wartosci_miesieczne_BTC, type = "multiplicative")


#wykresy skłądowych

plot(srednie_wartosci_miesieczne_BTC.dekomp.add)
plot(srednie_wartosci_miesieczne_BTC.dekomp.mult)
```



```{r}
adf.test()
```


```{r}
# model ARIMA(0,1,1)(0,1,0)
ARIMA.modelx <- Arima(srednie_wartosci_miesieczne_BTC,
                      order = c(1, 0, 1), seasonal = c(0, 1, 0)
                      )

#prognozy
ARIMA.modelx.prognozy <- forecast(ARIMA.modelx, h=24)


#pogdlad prognoz
ARIMA.modelx.prognozy$mean #prognozy punktowe
```


```{r}
ARIMA.modelx
```






teretyczny:
trend 
sezonowosc
Holta 
SARIMA


POPROSIC O PRACE, podselac porjekt


```{r}
plot(ARIMA.modelx.prognozy)

```



```{r}
#optymalny wzgledem AIC
arima.optymx.AIC <- auto.arima(srednie_wartosci_miesieczne_BTC, ic = "aic")
arima.optymx.AIC
```

```{r}
srednie_wartosci_miesieczne_BTC
```


```{r}
BTC_box
```


```{r}
InvBoxCox(BTC_box, lambda = 0)
```



```{r}
boxodw <- InvBoxCox(BTC_box.diff1.diff1, lambda = 0)
boxodw
```



```{r}
adf.test(boxodw)
```


METODA HOLTA-WINTERSA z uwzglednieniem sezonowości

```{r}
srednie_wartosci_miesieczne_BTC.hw.add <- hw(srednie_wartosci_miesieczne_BTC, h=24, seasonal = "additive")

srednie_wartosci_miesieczne_BTC.hw.mult <- hw(srednie_wartosci_miesieczne_BTC, h=24, seasonal = "multiplicative")


#wykresy
par(mfrow = c(3, 1))
plot(srednie_wartosci_miesieczne_BTC.hw.add, ylab= "LSK")
plot(srednie_wartosci_miesieczne_BTC.hw.mult, ylab= "LSK")
plot(srednie_wartosci_miesieczne_BTC.hw.mult$mean - srednie_wartosci_miesieczne_BTC.hw.add$mean,
     main = "roznica prognoz",
     ylab="")



```
obrazeknumer11

```{r}
srednie_wartosci_miesieczne_LSK.hw.add <- hw(srednie_wartosci_miesieczne_LSK, h=24, seasonal = "additive")

srednie_wartosci_miesieczne_LSK.hw.mult <- hw(srednie_wartosci_miesieczne_LSK, h=24, seasonal = "multiplicative")


#wykresy
par(mfrow = c(3, 1))
plot(srednie_wartosci_miesieczne_LSK.hw.add, ylab= "LSK")
plot(srednie_wartosci_miesieczne_LSK.hw.mult, ylab= "LSK")
plot(srednie_wartosci_miesieczne_LSK.hw.mult$mean - srednie_wartosci_miesieczne_LSK.hw.add$mean,
     main = "roznica prognoz",
     ylab="")
```


```{r}
#wykresy dopasowań
#wykresy
par(mfrow = c(2, 1))
plot(srednie_wartosci_miesieczne_BTC, ylab= "BTC",
     main = "Add algorytm H-W")
lines(fitted(srednie_wartosci_miesieczne_BTC.hw.add), lty = 2, col ="green")
legend("topleft",
       legend = c("oryginalny szereg","wartosci dopasowane"),
       col=c("black","green"), lty = c(1, 2))

plot(srednie_wartosci_miesieczne_BTC, ylab= "BTC",
     main = "Mult algorytm H-W")
lines(fitted(srednie_wartosci_miesieczne_BTC.hw.mult), lty = 2, col ="green")
legend("topleft",
       legend = c("oryginalny szereg","wartosci dopasowane"),
       col=c("black","green"), lty = c(1, 2))


```







```{r}
srednie_wartosci_miesieczne_BTC.hw.add$model
```

```{r}
srednie_wartosci_miesieczne_BTC.hw.mult$model
```




```{r}
#porownanie dokladnosci prognoz
kryteria <- c("MAE","RMSE","MAPE","MASE")

accuracy(srednie_wartosci_miesieczne_BTC.hw.add)[, kryteria]
```


```{r}
accuracy(srednie_wartosci_miesieczne_BTC.hw.mult)[, kryteria]

```


WAZNE (STRONA 300 uwaga61!)


Wykorzystanie funkcji 
```{r}
pacf(srednie_wartosci_miesieczne_LSK)
```


```{r}
lsk.hw1.add <- HoltWinters(srednie_wartosci_miesieczne_LSK, seasonal = "additive")
lsk.hw1.mult <- HoltWinters(srednie_wartosci_miesieczne_LSK, seasonal = "multiplicative")
lsk.hw1.add
```





```{r}
plot(lsk.hw1.add)
plot(lsk.hw1.mult)
```



```{r}
plot(fitted(lsk.hw1.mult))
```

obrazeknumer4

```{r}
acf(srednie_wartosci_miesieczne_LSK)
```

obrazeknumer5

```{r}
pacf(srednie_wartosci_miesieczne_LSK)
```



```{r}
# model ARIMA(0,1,1)(0,1,0)
ARIMA.modelxl <- Arima(srednie_wartosci_miesieczne_BTC.diff1.diff12,
                      order = c(1, 0, 1), seasonal = c(0, 1, 0)
                      )

#prognozy
ARIMA.modelxl.prognozy <- forecast(ARIMA.modelx, h=24)


#pogdlad prognoz
ARIMA.modelxl.prognozy$mean #prognozy punktowe
plot(ARIMA.modelxl.prognozy)
```

```{r}
BTC_box <- BoxCox(srednie_wartosci_miesieczne_BTC, lambda = 0)
BTC_box
tsdisplay(BTC_box)
```



```{r}
adf.test(BTC_box)
```


```{r}
BTC_box.diff1 <- diff(BTC_box, 1)

tsdisplay(BTC_box.diff1)
```


```{r}
adf.test(BTC_box.diff1)
```

```{r}
BTC_box.diff1.diff1 <- diff(BTC_box.diff1, 1)

tsdisplay(BTC_box.diff1.diff1)
```

```{r}
adf.test(BTC_box.diff1.diff1)


```

```{r}
#TUTAJ SOBIE TESTUJE
# model ARIMA(0,1,1)(0,1,0)
ARIMA.testowanie <- Arima(srednie_wartosci_miesieczne_BTC,
                      order = c(1, 0, 1), seasonal = c(0, 1, 0)
                      )

#prognozy
ARIMA.testowanie.prognozy <- forecast(ARIMA.modelx, h=24)


#pogdlad prognoz
plot(ARIMA.testowanie.prognozy)
```


```{r}
# model ARIMA(0,1,1)(0,1,0)
ARIMA.modelxl <- Arima(BTC_box.diff1.diff1,
                      order = c(1, 0, 1), seasonal = c(0, 1, 0)
                      )

#prognozy
ARIMA.modelxl.prognozy <- forecast(ARIMA.modelx, h=24)


#pogdlad prognoz
plot(ARIMA.modelxl.prognozy)
```



```{r}
par(mfrow = c(1, 2))
acf(srednie_wartosci_miesieczne_LSK)
pacf(srednie_wartosci_miesieczne_LSK)
```



```{r}
#inna rzecz
opcjanrdwa <- diff(BTC_box, 12)
tsdisplay(opcjanrdwa)
tsdisplay(BTC_box.diff1)
tsdisplay(BTC_box.diff1.diff1)

```
```{r}
adf.test(BTC_box.diff1)
```

```{r}
adf.test(BTC_box.diff1.diff1)
```

```{r}
# z acf ma1 
# z pacf ar2
# model ARIMA(0,1,1)(0,1,0)
ARIMA.modelbtcjeden <- Arima(srednie_wartosci_miesieczne_BTC,
                      order = c(0, 1, 1), seasonal = c(0, 1, 0)
                      )
ARIMA.modelbtcdwa <- Arima(srednie_wartosci_miesieczne_BTC,
                      order = c(2, 1, 0), seasonal = c(0, 1, 0)
                      )
ARIMA.modelbtctrzy <- Arima(srednie_wartosci_miesieczne_BTC,
                      order = c(0, 1, 0), seasonal = c(0, 1, 0)
                      )

#prognozy
ARIMA.modelbtcjeden.prognozy <- forecast(ARIMA.modelbtcjeden, h=18)
ARIMA.modelbtcdwa.prognozy <- forecast(ARIMA.modelbtcdwa, h=18)
ARIMA.modelbtctrzy.prognozy <- forecast(ARIMA.modelbtctrzy, h=18)


#pogdlad prognoz
par(mfrow = c(2,2))
plot(ARIMA.modelbtcjeden.prognozy)
plot(ARIMA.modelbtcdwa.prognozy)
plot(ARIMA.modelbtctrzy.prognozy)
```

```{r}
kryteria <- c("MAE","RMSE","MAPE","MASE")
```

```{r}
accuracy(ARIMA.modelbtcjeden.prognozy)[, kryteria]
```

```{r}
accuracy(ARIMA.modelbtcdwa.prognozy)[, kryteria]
```

```{r}
accuracy(ARIMA.modelbtctrzy.prognozy)[, kryteria]
```

```{r}
summary(ARIMA.modelbtcjeden.prognozy)
```

```{r}
summary(ARIMA.modelbtcdwa.prognozy)
```

```{r}
summary(ARIMA.modelbtctrzy.prognozy)
```


```{r}
plot(ARIMA.modelbtcjeden.prognozy)
```


```{r}
ARIMA.modelbtcjedentest <- Arima(srednie_wartosci_miesieczne_BTC,
                      order = c(2, 2, 1), seasonal = c(0, 1, 0)
                      )

ARIMA.modelbtcjedentest.prognozy <- forecast(ARIMA.modelbtcjedentest, h=24)
#srednie_wartosci_miesieczne_BTC.hw.add
#ARIMA.modelbtcjedentest.prognozy
plot(ARIMA.modelbtcjedentest.prognozy)
lines(srednie_wartosci_miesieczne_BTC_fo, col = "red", lty=2)
##lty=2, lwd=2
grid()
```


```{r}
#order = c(0, 0, 1), seasonal = c(1, 1, 0)
ARIMA.modellskjedentest <- Arima(srednie_wartosci_miesieczne_LSK,
                      order = c(0, 0, 1), seasonal = c(1, 1, 0)
                      )

ARIMA.modellskjedentest.prognozy <- forecast(ARIMA.modellskjedentest, h=24)

plot(ARIMA.modellskjedentest.prognozy)
lines(srednie_wartosci_miesieczne_LSK_f, col = "red", lty=2)
##lty=2, lwd=2
grid()

```





```{r}
kryteria <- c("MAE","RMSE","MAPE","MASE")
```

```{r}
accuracy(ARIMA.modelbtcjeden.prognozy)[, kryteria]
```

```{r}
accuracy(ARIMA.modelbtcdwa.prognozy)[, kryteria]
```

```{r}
accuracy(ARIMA.modelbtctrzy.prognozy)[, kryteria]
```



```{r}
adf.test(opcjanrdwa)
```

```{r}
opcjanrtrzy <- diff(opcjanrdwa, 1)
tsdisplay(opcjanrtrzy)
```

```{r}
adf.test(opcjanrtrzy)
```

############### DLA LSK ########################

```{r}
LSK_box <- BoxCox(srednie_wartosci_miesieczne_LSK, lambda = 0)
LSK_box
tsdisplay(LSK_box)
```



```{r}
adf.test(LSK_box)
```


```{r}
LSK_box.diff1 <- diff(LSK_box, 1)

tsdisplay(LSK_box.diff1)
```


```{r}
adf.test(LSK_box.diff1)
```

```{r}
LSK_box.diff1.diff1 <- diff(LSK_box.diff1, 1)

tsdisplay(LSK_box.diff1.diff1)
```

```{r}
adf.test(LSK_box.diff1.diff1)


```

```{r}
LSK_box.diff1.diff1.diff1 <- diff(LSK_box.diff1.diff1, 1)

tsdisplay(LSK_box.diff1.diff1.diff1)
```

```{r}
adf.test(LSK_box.diff1.diff1.diff1)
```

```{r}
# z acf ma1 
# z pacf ar2
# model ARIMA(0,1,1)(0,1,0)


##ARIMA.modellskjeden <- Arima(srednie_wartosci_miesieczne_LSK,
 ##                     order = c(0, 0, 1), seasonal = c(0, 1, 0)
##                      )
##ARIMA.modellskdwa <- Arima(srednie_wartosci_miesieczne_LSK,
  ##                    order = c(2, 0, 1), seasonal = c(0, 1, 0)
 ##                     )
##ARIMA.modellsktrzy <- Arima(srednie_wartosci_miesieczne_LSK,
 ##                     order = c(0, 0, 1), seasonal = c(1, 1, 0)
  ##                    )
ARIMA.modellskjeden <- Arima(srednie_wartosci_miesieczne_LSK,
                      order = c(0, 1, 1), seasonal = c(0, 1, 0)
                      )
#2,1,1 0,1,0 [12] byl lepszy
ARIMA.modellsktrzy <- Arima(srednie_wartosci_miesieczne_LSK,
                      order = c(0, 1, 0), seasonal = c(0, 1, 0))
ARIMA.modellskcztery<- Arima(srednie_wartosci_miesieczne_LSK,
                      order = c(2, 1, 0), seasonal = c(0, 1, 0))

#prognozy
ARIMA.modellskjeden.prognozy <- forecast(ARIMA.modellskjeden, h=18)
ARIMA.modellsktrzy.prognozy <- forecast(ARIMA.modellsktrzy, h=18)
ARIMA.modellskcztery.prognozy <- forecast(ARIMA.modellskcztery, h=18)

#pogdlad prognoz
par(mfrow = c(2,2))
plot(ARIMA.modellskjeden.prognozy)
plot(ARIMA.modellsktrzy.prognozy)
plot(ARIMA.modellskcztery.prognozy)
```

```{r}
kryteria <- c("MAE","RMSE","MAPE","MASE")
```

```{r}
accuracy(ARIMA.modellskjeden.prognozy)[, kryteria]
```


```{r}
#1,47 2,47 22,8 0,211
accuracy(ARIMA.modellsktrzy.prognozy)[, kryteria]
```

```{r}
accuracy(ARIMA.modellskcztery.prognozy)[, kryteria]
```

```{r}
summary(ARIMA.modellskjeden.prognozy)
```


```{r}
summary(ARIMA.modellsktrzy.prognozy)
```

```{r}
summary(ARIMA.modellskcztery.prognozy)
```

```{r}
plot(ARIMA.modellskjeden.prognozy)
```


```{r}
d.optlsk <- ndiffs(srednie_wartosci_miesieczne_BTC)
d.optlsk
```

male d=1 
 
```{r}
D.optlsk <- nsdiffs(srednie_wartosci_miesieczne_BTC)
D.optlsk
```

D=0

```{r}
# model ARIMA(0,1,1)(0,1,0)
ARIMA.modelxl <- Arima(BTC_box.diff1.diff1,
                      order = c(1, 0, 1), seasonal = c(0, 1, 0)
                      )

#prognozy
ARIMA.modelxl.prognozy <- forecast(ARIMA.modelxl, h=24)


#pogdlad prognoz
plot(ARIMA.modelxl.prognozy)
```

```{r}
auto.arima(BTC_box.diff1.diff1, seasonal = FALSE)
```

```{r}
srednie_wartosci_miesieczne_LSK.hw.add <- hw(srednie_wartosci_miesieczne_LSK, h=18, seasonal = "additive")

plot(srednie_wartosci_miesieczne_LSK.hw.add)
```

```{r}
srednie_wartosci_miesieczne_BTC.hw.add <- hw(srednie_wartosci_miesieczne_BTC, h=18, seasonal = "additive")

plot(srednie_wartosci_miesieczne_BTC.hw.add)
```



```{r}
plot(LSK_box.diff1.diff1.diff1)
```

```{r}
par(mfrow=c(2, 1))
acf(BTC_box.diff1.diff1)
pacf(BTC_box.diff1.diff1)
```

```{r}
tsdisplay(BTC.mie$Close.mean)
tsdisplay(srednie_wartosci_miesieczne_LSK.diff12)
yzk <- c(1000,5000,15000,1000,5000,15000)


plot(ARIMA.modelbtcjeden.prognozy)
lines(srednie_wartosci_miesieczne_BTC, col = "red", lty=2, lwd=2)
grid()
```







```{r}
BTC_fo <- read.xlsx("data/BTC_forecast.xlsx", sheet = 1)
```


```{r}
LSK_f <-read.xlsx("data/LSK_forecast.xlsx", sheet = 1)
```

```{r}
LSK_f$Close = as.numeric(LSK_f$Close)
```

```{r}
LSK_f$Miesiac = as.factor(LSK_f$Miesiac)
```

```{r}
BTC_fo$Close = as.numeric(BTC_fo$Close)
```

```{r}
BTC_fo$Miesiac = as.factor(BTC_fo$Miesiac)
```


```{r}
class(BTC_f)
```

```{r}
LSK_f.mie <- LSK_f %>%   filter(Rok %in% c(2016, 2017, 2018, 2019)) %>% 
    select(Rok, Miesiac, Close) %>% na.omit() %>%
    mutate(Miesiac = factor(month.name[Miesiac], levels=month.name[1:12]),
           Rok = factor(Rok),
           Close.CEL = (Close)) %>%    
    group_by(Rok, Miesiac) %>% summarise(Close.mean = round(mean(Close.CEL),2))

 
head(LSK_f.mie)
```


```{r}
asd<- BTC_f
```


```{r}
BTC_fo.mie <- BTC_fo %>%   filter(Rok %in% c(2013, 2014, 2015, 2016, 2017, 2018, 2019)) %>% 
    select(Rok, Miesiac, Close) %>% na.omit() %>%
    mutate(Miesiac = factor(month.name[Miesiac], levels=month.name[1:12]),
           Rok = factor(Rok),
           Close.CEL = (Close)) %>%    
    group_by(Rok, Miesiac) %>% summarise(Close.mean = round(mean(Close.CEL),2))

 
head(BTC_fo.mie)
```

```{r}
LSK_f_M<-c(LSK_f.mie$Close.mean)
srednie_wartosci_miesieczne_LSK_f <- ts(LSK_f_M, start=c(2016,4), frequency=12)
srednie_wartosci_miesieczne_LSK_f
```

```{r}
BTC_fo_M<-c(BTC_fo.mie$Close.mean)
srednie_wartosci_miesieczne_BTC_fo <- ts(BTC_fo_M, start=c(2013,4), frequency=12)
srednie_wartosci_miesieczne_BTC_fo
```

```{r}
plot(srednie_wartosci_miesieczne_BTC.hw.add)
lines(srednie_wartosci_miesieczne_BTC_fo, col = "red")
##lty=2, lwd=2
grid()
```

```{r}
plot(srednie_wartosci_miesieczne_BTC.hw.add)
```

```{r}
kryteria <- c("MAE","RMSE","MAPE","MASE")
```

```{r}
accuracy(srednie_wartosci_miesieczne_LSK.hw.add)[, kryteria]
```

```{r}
accuracy(srednie_wartosci_miesieczne_BTC.hw.add)[,kryteria]
```

```{r}
summary(srednie_wartosci_miesieczne_LSK.hw.add)
```

```{r}
summary(srednie_wartosci_miesieczne_BTC.hw.add)
```

```{r}
tst<- BTC.mie$Close.mean
tst
```

```{r}
abcs <- tail(tst, 32)
abcs 
```

```{r}
str(abcs)
```


```{r}
LSK.mie$Close.mean
```

```{r}
cor.test(abcs, LSK.mie$Close.mean, method = "pearson")
```

